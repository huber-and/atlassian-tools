/*
 * The Confluence Cloud REST API
 * This document describes the REST API and resources provided by Confluence. The REST APIs are for developers who want to integrate Confluence into their application and for administrators who want to script interactions with the Confluence server.Confluence's REST APIs provide access to resources (data entities) via URI paths. To use a REST API, your application will make an HTTP request and parse the response. The response format is JSON. Your methods will be the standard HTTP methods like GET, PUT, POST and DELETE. Because the REST API is based on open standards, you can use any web development language to access the API.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package net.atlassian.wiki.rest.v1.api;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.StringJoiner;

import com.fasterxml.jackson.core.type.TypeReference;

import net.atlassian.wiki.rest.ApiClient;
import net.atlassian.wiki.rest.ApiException;
import net.atlassian.wiki.rest.BaseApi;
import net.atlassian.wiki.rest.Configuration;
import net.atlassian.wiki.rest.Pair;

@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-11-23T15:49:46.657254+01:00[Europe/Berlin]", comments = "Generator version: 7.17.0")
public class ContentAttachmentsApi extends BaseApi {

	public ContentAttachmentsApi() {
		super(Configuration.getDefaultApiClient());
	}

	public ContentAttachmentsApi(ApiClient apiClient) {
		super(apiClient);
	}

	/**
	 * Create or update attachment Adds an attachment to a piece of content. If the
	 * attachment already exists for the content, then the attachment is updated
	 * (i.e. a new version of the attachment is created). Note, you must set a
	 * &#x60;X-Atlassian-Token: nocheck&#x60; header on the request for this method,
	 * otherwise it will be blocked. This protects against XSRF attacks, which is
	 * necessary as this method accepts multipart/form-data. The media type
	 * &#39;multipart/form-data&#39; is defined in [RFC
	 * 7578](https://www.ietf.org/rfc/rfc7578.txt). Most client libraries have
	 * classes that make it easier to implement multipart posts, like the
	 * [MultipartEntityBuilder](https://hc.apache.org/httpcomponents-client-5.1.x/current/httpclient5/apidocs/)
	 * Java class provided by Apache HTTP Components. Note, according to [RFC
	 * 7578](https://tools.ietf.org/html/rfc7578#section-4.5), in the case where the
	 * form data is text, the charset parameter for the \&quot;text/plain\&quot;
	 * Content-Type may be used to indicate the character encoding used in that
	 * part. In the case of this API endpoint, the &#x60;comment&#x60; body
	 * parameter should be sent with &#x60;type&#x3D;text/plain&#x60; and
	 * &#x60;charset&#x3D;utf-8&#x60; values. This will force the charset to be
	 * UTF-8. Example: This curl command attaches a file (&#39;example.txt&#39;) to
	 * a piece of content (id&#x3D;&#39;123&#39;) with a comment and
	 * &#x60;minorEdits&#x60;&#x3D;true. If the &#39;example.txt&#39; file already
	 * exists, it will update it with a new version of the attachment.
	 * &#x60;&#x60;&#x60; bash curl -D- \\ -u admin:admin \\ -X PUT \\ -H
	 * &#39;X-Atlassian-Token: nocheck&#39; \\ -F
	 * &#39;file&#x3D;@\&quot;example.txt\&quot;&#39; \\ -F
	 * &#39;minorEdit&#x3D;\&quot;true\&quot;&#39; \\ -F
	 * &#39;comment&#x3D;\&quot;Example attachment comment\&quot;;
	 * type&#x3D;text/plain; charset&#x3D;utf-8&#39; \\
	 * http://myhost/rest/api/content/123/child/attachment &#x60;&#x60;&#x60;
	 * **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	 * Permission to update the content.
	 * 
	 * @param id        The ID of the content to add the attachment to. (required)
	 * @param _file     The relative location and name of the attachment to be added
	 *                  to the content. (required)
	 * @param minorEdit If &#x60;minorEdits&#x60; is set to &#39;true&#39;, no
	 *                  notification email or activity stream will be generated when
	 *                  the attachment is added to the content. (required)
	 * @param status    The status of the content that the attachment is being added
	 *                  to. This should always be set to &#39;current&#39;.
	 *                  (optional, default to current)
	 * @param comment   The comment for the attachment that is being added. If you
	 *                  specify a comment, then every file must have a comment and
	 *                  the comments must be in the same order as the files.
	 *                  Alternatively, don&#39;t specify any comments. (optional)
	 * @return ContentArray
	 * @throws ApiException if fails to make API call
	 */
	public void createOrUpdateAttachments(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull File _file,
			@jakarta.annotation.Nonnull String minorEdit, @jakarta.annotation.Nullable String status,
			@jakarta.annotation.Nullable String comment) throws ApiException {
		this.createOrUpdateAttachments(id, _file, minorEdit, status, comment, Collections.emptyMap());
	}

	/**
	 * Create or update attachment Adds an attachment to a piece of content. If the
	 * attachment already exists for the content, then the attachment is updated
	 * (i.e. a new version of the attachment is created). Note, you must set a
	 * &#x60;X-Atlassian-Token: nocheck&#x60; header on the request for this method,
	 * otherwise it will be blocked. This protects against XSRF attacks, which is
	 * necessary as this method accepts multipart/form-data. The media type
	 * &#39;multipart/form-data&#39; is defined in [RFC
	 * 7578](https://www.ietf.org/rfc/rfc7578.txt). Most client libraries have
	 * classes that make it easier to implement multipart posts, like the
	 * [MultipartEntityBuilder](https://hc.apache.org/httpcomponents-client-5.1.x/current/httpclient5/apidocs/)
	 * Java class provided by Apache HTTP Components. Note, according to [RFC
	 * 7578](https://tools.ietf.org/html/rfc7578#section-4.5), in the case where the
	 * form data is text, the charset parameter for the \&quot;text/plain\&quot;
	 * Content-Type may be used to indicate the character encoding used in that
	 * part. In the case of this API endpoint, the &#x60;comment&#x60; body
	 * parameter should be sent with &#x60;type&#x3D;text/plain&#x60; and
	 * &#x60;charset&#x3D;utf-8&#x60; values. This will force the charset to be
	 * UTF-8. Example: This curl command attaches a file (&#39;example.txt&#39;) to
	 * a piece of content (id&#x3D;&#39;123&#39;) with a comment and
	 * &#x60;minorEdits&#x60;&#x3D;true. If the &#39;example.txt&#39; file already
	 * exists, it will update it with a new version of the attachment.
	 * &#x60;&#x60;&#x60; bash curl -D- \\ -u admin:admin \\ -X PUT \\ -H
	 * &#39;X-Atlassian-Token: nocheck&#39; \\ -F
	 * &#39;file&#x3D;@\&quot;example.txt\&quot;&#39; \\ -F
	 * &#39;minorEdit&#x3D;\&quot;true\&quot;&#39; \\ -F
	 * &#39;comment&#x3D;\&quot;Example attachment comment\&quot;;
	 * type&#x3D;text/plain; charset&#x3D;utf-8&#39; \\
	 * http://myhost/rest/api/content/123/child/attachment &#x60;&#x60;&#x60;
	 * **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	 * Permission to update the content.
	 * 
	 * @param id                The ID of the content to add the attachment to.
	 *                          (required)
	 * @param _file             The relative location and name of the attachment to
	 *                          be added to the content. (required)
	 * @param minorEdit         If &#x60;minorEdits&#x60; is set to &#39;true&#39;,
	 *                          no notification email or activity stream will be
	 *                          generated when the attachment is added to the
	 *                          content. (required)
	 * @param status            The status of the content that the attachment is
	 *                          being added to. This should always be set to
	 *                          &#39;current&#39;. (optional, default to current)
	 * @param comment           The comment for the attachment that is being added.
	 *                          If you specify a comment, then every file must have
	 *                          a comment and the comments must be in the same order
	 *                          as the files. Alternatively, don&#39;t specify any
	 *                          comments. (optional)
	 * @param additionalHeaders additionalHeaders for this call
	 * @return ContentArray
	 * @throws ApiException if fails to make API call
	 */
	public void createOrUpdateAttachments(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull File _file,
			@jakarta.annotation.Nonnull String minorEdit, @jakarta.annotation.Nullable String status,
			@jakarta.annotation.Nullable String comment, Map<String, String> additionalHeaders) throws ApiException {
		Object localVarPostBody = null;

		// verify the required parameter 'id' is set
		if (id == null) {
			throw new ApiException(400, "Missing the required parameter 'id' when calling createOrUpdateAttachments");
		}

		// verify the required parameter '_file' is set
		if (_file == null) {
			throw new ApiException(400,
					"Missing the required parameter '_file' when calling createOrUpdateAttachments");
		}

		// verify the required parameter 'minorEdit' is set
		if (minorEdit == null) {
			throw new ApiException(400,
					"Missing the required parameter 'minorEdit' when calling createOrUpdateAttachments");
		}

		// create path and map variables
		String localVarPath = "/content/{id}/child/attachment".replaceAll("\\{" + "id" + "\\}",
				apiClient.escapeString(apiClient.parameterToString(id)));

		StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
		String localVarQueryParameterBaseName;
		List<Pair> localVarQueryParams = new ArrayList<Pair>();
		List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
		Map<String, String> localVarHeaderParams = new HashMap<String, String>();
		Map<String, String> localVarCookieParams = new HashMap<String, String>();
		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		localVarQueryParams.addAll(apiClient.parameterToPair("status", status));

		localVarHeaderParams.putAll(additionalHeaders);

		if (_file != null) {
			localVarFormParams.put("file", _file);
		}
		if (comment != null) {
			localVarFormParams.put("comment", comment);
		}
		if (minorEdit != null) {
			localVarFormParams.put("minorEdit", minorEdit);
		}

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

		final String[] localVarContentTypes = { "multipart/form-data" };
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

		String[] localVarAuthNames = new String[] { "basicAuth", "oAuthDefinitions" };

		TypeReference<String> localVarReturnType = new TypeReference<String>() {
		};
		apiClient.invokeAPI(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams,
				localVarQueryStringJoiner.toString(), localVarPostBody, localVarHeaderParams, localVarCookieParams,
				localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, null);
	}

	@Override
	public <T> T invokeAPI(String url, String method, Object request, TypeReference<T> returnType,
			Map<String, String> additionalHeaders) throws ApiException {
		String localVarPath = url.replace(apiClient.getBaseURL(), "");
		StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
		List<Pair> localVarQueryParams = new ArrayList<Pair>();
		List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
		Map<String, String> localVarHeaderParams = new HashMap<String, String>();
		Map<String, String> localVarCookieParams = new HashMap<String, String>();
		Map<String, Object> localVarFormParams = new HashMap<String, Object>();

		localVarHeaderParams.putAll(additionalHeaders);

		final String[] localVarAccepts = { "application/json" };
		final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

		final String[] localVarContentTypes = { "application/json" };
		final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

		String[] localVarAuthNames = new String[] { "basicAuth", "oAuthDefinitions" };

		return apiClient.invokeAPI(localVarPath, method, localVarQueryParams, localVarCollectionQueryParams,
				localVarQueryStringJoiner.toString(), request, localVarHeaderParams, localVarCookieParams,
				localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, returnType);
	}
}
